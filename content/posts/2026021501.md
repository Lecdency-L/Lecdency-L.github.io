+++
date = '2026-02-15T13:56:35+08:00'
draft = false
title = 'debug SOP'
tags = ["技术","工程","更新中"]
+++

## 1 三种视角
1. 功能正确性（本地测试、单请求）
2. 并发稳定性（ToC）
3. 业务一致性（ToB）

### 1.1 ToB和ToC的区别

| 维度      | ToC   | ToB   |
| ------- | ----- | ----- |
| 用户量     | 大     | 小     |
| 并发      | 高     | 中低    |
| 单笔价值    | 低     | 高     |
| 核心风险    | 系统崩溃  | 数据错误  |
| Debug难点 | 性能与并发 | 业务与状态 |


## 2 功能正确性
### 2.1 调用链定位
不要一上来打断点，因为断点只对当前进程有效，而问题可能发生在网关、限流器、熔断器或上游服务。
```
客户端
→ 网关
→ 鉴权/限流
→ 业务服务 Controller
→ Service
→ DAO
→ 下游服务 / 数据库
```

#### 2.1.1 网关

网关是整个微服务系统的“唯一入口”，它不做业务，只做流量分发与横切控制。

**构成**

```
客户端
→ Spring Cloud Gateway（基于 Netty）
→ 服务发现（Nacos）
→ LoadBalancer 选实例
→ 转发到目标服务
```

| 功能           | 使用组件                      |
| ------------ | ------------------------- |
| API 网关       | Spring Cloud Gateway      |
| 服务注册         | Nacos                     |
| 客户端负载均衡      | Spring Cloud LoadBalancer |
| WebSocket 转发 | Gateway（Netty实例1） + NettyService（Netty实例2）           |
| 跨域处理         | Gateway 内置 CORS           |


**作用**

路由分发/鉴权/限流（IP/用户/接口）/traceId/QPS

鉴权也可以专门用一个模块来做


**使用**

1
先启动Nacos（服务目录）：所有服务启动时注册自己，GateWay从Nacos获得可用实例。

2
启动存储、缓存、业务服务，将自己注册到nacos

```yaml
spring:
  application:
    name: AuthenticationService
  cloud:
    nacos:
      discovery:
        server-addr: 127.0.0.1:18375 # nacos运行在18375端口，去这个端口注册当前服务
        ip: 127.0.0.1
        port: 8082
```

GateWay模块：
```yaml
spring:
  application:
    name: gateway
  cloud:
    nacos:
      discovery:
        server-addr: 127.0.0.1:18375  # nacos运行在18375，提供可用实例
    gateway:
      routes:
        - id: AuthenticationService
          uri: lb://AuthenticationService # 负载均衡模式，在可用实例之间选择
```

3
启动GateWayApplication.java（整个模块的关键信息都在配置文件中）


**备注**

该网关使用少量线程处理大量请求，属于事件驱动模型。基于Spring WebFlux，底层是Netty，非阻塞IO，只有少量EventLoop线程。

相对的，Servlet模型（Tomcat）是线程和请求一一对应的，线程阻塞等待IO，执行完才释放，可以使用ThreadLocal。

得出结论：阻塞代码会拖死整个事件循环线程

所以不要在网关查数据库/执行复杂逻辑；可以做：路由/鉴权/限流/Header 处理

CORS（cross-origin resource sharing）

CORS 是为了防止：比如同时登录了银行网站和恶意网站，恶意网站通过cookie对银行服务器发送恶意请求（可能生成响应，但是会被浏览器拦截）从而能防止恶意网站在浏览器环境下，利用用户的登录状态读取敏感数据

CORS 保护的是“数据读取”，不是“状态变更”。

前端只访问网关，所以在网关配置CORS
```yaml
globalcors:
  cors-configurations:
    '[/**]':
      allowedOrigins:
        - "http://localhost:5137" # 前端运行在5137端口，允许其访问网关
      allowedMethods:
        - GET
        - POST
```

CORS是浏览器策略，对curl/postman等无效。

#### 2.1.2 服务层功能性问题

**环境**

运行环境 ≠ 运行环境

典型表现：编译通过 + 运行报 NoSuchMethodError/ClassNotFoundException

原因：JDK版本和某些依赖库不兼容/库的问题/本地和服务器classpath不一致

**请求上下文**

```
客户端分三类：
- 浏览器
- 脚本工具
- 服务间调用
```

表现：本地curl/postman正常，网页版工具异常

浏览器环境和非浏览器环境的差异

包括：CORS/Cookies/Header等问题

**类型系统**

JSON是弱类型，Java是强类型。

JSON 传输层无类型约束，Java 反序列化依赖字段定义

表现：JSON 里 userId 是字符串，Java 接口写成 Integer，雪花算法 Long 被截断

**总结**

1. 确认运行环境一致
2. 确认请求来源一致
3. 确认类型边界一致
